name: Release and Version Management

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  # Build and test
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Get full history for changelog generation

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint || echo "Linting completed with warnings"
        continue-on-error: true

      - name: Build project
        run: npm run build
        env:
          NEXT_PUBLIC_APP_VERSION: ${{ github.sha }}

  # Release version (only on main branch push)
  release:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate version number
        id: version
        run: |
          # Get latest tag
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          
          # Parse version number
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"
          
          # Determine version increment based on commit type
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if [[ $COMMIT_MSG == *"feat:"* ]] || [[ $COMMIT_MSG == *"feat("* ]]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          elif [[ $COMMIT_MSG == *"fix:"* ]] || [[ $COMMIT_MSG == *"fix("* ]]; then
            PATCH=$((PATCH + 1))
          else
            PATCH=$((PATCH + 1))
          fi
          
          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "New version: $NEW_VERSION"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "tag=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Generate CHANGELOG
        id: changelog
        run: |
          # Get previous tag
          PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1 2>/dev/null || echo "")
          
          if [ -n "$PREVIOUS_TAG" ]; then
            # Generate changelog from previous tag to now
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" $PREVIOUS_TAG..HEAD)
          else
            # If no previous tag, show recent commits
            CHANGELOG=$(git log --pretty=format:"- %s (%h)" -10)
          fi
          
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "## ${{ steps.version.outputs.version }} ($(date +'%Y-%m-%d'))" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### New Features" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" | grep -E "feat:|feat\(" || echo "- No new features" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Bug Fixes" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" | grep -E "fix:|fix\(" || echo "- No fixes" >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "### Other Changes" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" | grep -vE "feat:|fix:|feat\(|fix\(" || echo "- No other changes" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Git tag
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git tag -a "${{ steps.version.outputs.version }}" -m "Release ${{ steps.version.outputs.version }}"
          git push origin "${{ steps.version.outputs.version }}"

      - name: Update CHANGELOG.md
        run: |
          # Insert new changelog at the beginning of file
          {
            echo "${{ steps.changelog.outputs.changelog }}"
            echo ""
            if [ -f CHANGELOG.md ]; then
              cat CHANGELOG.md
            fi
          } > CHANGELOG_TEMP.md
          mv CHANGELOG_TEMP.md CHANGELOG.md
          
          # Commit CHANGELOG.md
          git add CHANGELOG.md
          git commit -m "docs: update CHANGELOG.md for ${{ steps.version.outputs.version }}" || exit 0
          git push origin main

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version.outputs.version }}
          release_name: Release ${{ steps.version.outputs.version }}
          body: |
            ${{ steps.changelog.outputs.changelog }}
            
            ## Rollback Guide
            
            If this version has issues, you can quickly rollback using the following methods:
            
            ### Vercel Rollback
            ```bash
            # View deployment history
            vercel ls
            
            # Rollback to previous version
            vercel promote <previous_deployment_id>
            ```
            
            ### Git Rollback
            ```bash
            # Rollback to previous commit
            git revert -m 1 <merge_sha>
            git push origin main
            ```
            
            ### Database Rollback
            ```bash
            # Restore database to previous backup
            ./scripts/restore_db.sh backups/backup_YYYYMMDD_HHMMSS.sql
            ```
          draft: false
          prerelease: false

  # Database backup (only on main branch push)
  backup-database:
    needs: build-and-test
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Database backup
        run: |
          # Create backup directory
          mkdir -p backups
          
          # Generate backup filename
          BACKUP_FILE="backup_$(date +%Y%m%d_%H%M%S).sql"
          
          # Check if database connection info is available
          if [ -n "${{ secrets.SUPABASE_DB_URL }}" ]; then
            echo "Backing up database..."
            # Adjust according to actual Supabase connection method
            echo "-- Database backup file" > backups/$BACKUP_FILE
            echo "-- Time: $(date)" >> backups/$BACKUP_FILE
            echo "-- Version: ${{ github.sha }}" >> backups/$BACKUP_FILE
            echo "-- Note: Please manually execute database backup script" >> backups/$BACKUP_FILE
          else
            echo "Warning: SUPABASE_DB_URL not configured, skipping backup"
          fi

      - name: Upload backup file
        uses: actions/upload-artifact@v4
        with:
          name: database-backup-${{ github.sha }}
          path: backups/
          retention-days: 30
